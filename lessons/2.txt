PSR-7 фреймворк 2/7: Контроллеры и маршрутизация


Запуск сервера встроенного в PHP на localhost
    php -S 0.0.0.0:8080 -t public public/index.php
Проверяем в браузере
    http://0.0.0.0:8080/?name=Igor!!!!!

Можем разбить выполнение кода на логические шаги
    ### Initialization

    ### Preprocessing

    ### Action

    ### Postprocessing

    ### Sending

Чтобы получить запрашиваемый путь мы можем воспользоваться реализованными методами.
    $path = $request->getUri()->getPath();

Для маршрутизации, вопрос в лоб можно решить например так
    if ($path === '/') {
        $name = $request->getQueryParams()['name'] ?? 'Guest';
        $response = new HtmlResponse('Hello, ' . $name . '!');
    } elseif ($path === '/about') {
        $response = new HtmlResponse('I am a simple site');
    } elseif ($path === '/blog') {
        $response = new JsonResponse([
            ['id' => 2, 'title' => 'The Second Post'],
            ['id' => 1, 'title' => 'The First Post'],
        ]);
    .........

Для лучшего подхода можем сделать реализацию через анонимные функции (прячем в них логику экшена).
    т.е. в маршрутах описываем анонимные функции.
        ......
        } elseif ($path === '/about') {
            $action = function (ServerRequestInterface $request) {
                return new HtmlResponse('I am a simple site');
            };
        ......
  и в конце после описания этих роутов, эту анонимную функцию вызываем.
        if ($action) {
            $response = $action($request);


Паттерн Web-MVC костыльный вариант классического MVC.

ADR - Action Domain Response
        в зависимости от реквеста вызывается экшн, который обращается к доменной модели,
         получает от нее данные и возвращает Response.


Нам нужен норм роутер.
    сделаем в 2 шага
        1. Создадим коллекцию роутов
                $routes = new RouteCollection();
            Заполним ее роутами метод и в него роут и анонимная функция.
                $routes->get('/', function() {return 'Hello'});
                $routes->post('/blog/', function() {return 'Create Post'});
        2. Далее создаем объект роут, передавая в него сведения о всех возможных роутах.
                $router = new Router($collection);
            потом матчим реквест
                $result = $router->match($request);
Стартовая реализация такой маршрутизации в


1. Вначале написали тест, потом код, потом проверили, что все работает. TDD
2. Рефакторинг полученного.


??? Есть паттерн InformationExpert по нему желательно, что методы, работающие с определенными данными
помещались внутрь того класса с которым рабатает.


Теоритечески в дальнейшем программист может захотеть реализовать свой СуперРоут и
выход конечно же создать Интерфейс.

==========================================================================================

Создаем Экшены HelloAction и т.д. с методом __invoke() {..} и в  index.php
теперь можем задавать роуты
    $routes->get('home', '/', new Action\HelloAction());
    $routes->get('about', '/about', new Action\AboutAction());
    $routes->get('blog', '/blog', new Action\Blog\IndexAction());
    $routes->get('blog_show', '/blog/{id}', new Action\Blog\ShowAction(), ['id' => '\d+']);

Все работает, но пока что классы не очень сложные в них не передаются в конструкторы никакие объекты,
  также недостаток, что при задании роутов происходит создание объектов.

===========================================================================================

Вообще от маршрутизатора нам нужна поддержка PSR-7 интерфейса RequestInterface.
т.е. из готовых пакетов мы можем выбрать например
    FastRoute
    Aura Router
    Symfony Router
    Zend Router

В этом проекте мы решили воспользоваться Aura Router.
    Добавим его в проект зависимотью.
            composer require aura/router

Чтобы не терять свой код, работающий с уже имеющимся нашим самописным роутером,
  выделим для него интерфейс Router с двумя офязательными методами  math() и generate().
  А для работы с новым Aura Router нам нужно создать адаптер AuraRouterAdapter.
  Если в дальнейшем, мы захотим сменить роутер на Zend например, то напишем
   какой-нибудь ZendRouterAdapter, и также без проблем сможем начать его использовать.

Хорошая практика использование абстракций заданных базовыми интерфейсами.




